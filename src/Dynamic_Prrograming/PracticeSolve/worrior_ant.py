'''
이웃한 리스트는 더할 수 없고 떨어져있는 리스트만 더해서 최댓값을 구하는 문제이다
이러한 dp의 경우 점화식을 잘 구해야 코드로 옮기는 것에 문제가 없다.
해당 문제의 경우 해답지를 보면서 깨닿게 되어 주석으로 하나씩 집고 가려한다.
'''
n = int(input())

num = list(map(int, input().split()))

dp = [0] * (n + 1)

dp[0], dp[1] = num[0], max(num[0], num[1])

# 바텀업의 방식, for문으로 하나씩 작은 부분부터 큰부분으로 접근
for i in range(2, n + 1):
    # dp의 값은 2부터 시작을한다. 다만 2부터 시작을 하면서 dp[i]의 경우 max값 비교를 통해 비교를 한다.
    # 만약 dp[i-1]이 그 이전의 값 dp[i-2] + num[i]보다 크다면 해당 리스트에는 이전의 값을 그대로 더해주고 넘어가는 식이다
    # 이러한 방식으로 n의 값까지 더해가면 해당 최댓값이 등장하게 된다.
    # 처음에는 해당 리스트의 비교를 생각하지 못해서 dp의 값에 각 겹치지 않는 경우를 다 더하려고했지만 코드의 구현을 실패했었다.
    # 해당 문제처럼 비교하는 부분의 값을 넣어주는 dp의 경우 잘 접근하지못하고 풀지 못하는 것 같다.
    dp[i] = max(dp[i - 1], dp[i - 2] + num[i])

print(dp[n - 1])
